""" This module contains classes representing the state of an object in the
simulation. These states contain information describing the object and may be
passed to agents to enable decision making. """

__author__ = 'lrbenke, mikepsn'

class SensorTrack(object):
    """ Data generated by the sensor model for each entity it is tracking. """
    def __init__(self):
        self.callsign = ''
        self.id = None
        self.side = None
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.v = 0.0
        self.track_range = 0.0
        self.track_theta = 0.0
        self.track_psi = 0.0
        self.start_time = 0.0
        self.current_time = 0.0
        self.total_time = 0.0

class SensorState(object):
    """ Defines the current state of the sensor model. """
    def __init__(self):
        self.name = ""
        self.max_range = 10000.0
        self.fov = 60.0
        self.tracks = {}


class FighterState(object):
    """ Defines the current state of the Fighter. """
    def __init__(self, x, y, z, z_c, psi, psi_c, theta, theta_c,
                 phi, phi_c, v, v_c, gload, v_min, v_max):
        self.timestep = 0.0
        self.callsign = "callsign"  # aircraft's unique callsign
        self.id = 0             # unique aircraft id (starting at 0)
        self.side = 1           # side aircraft belongs to (either 1 or 2)
        self.actype = 0         # aircraft type
        self.x = x              # x position or lat
        self.y = y              # y position or lon
        self.z = z              # z position or altitude
        self.z_c = z_c          # desired altitude
        self.psi = psi          # heading
        self.psi_c = psi_c      # desired heading
        self.theta = theta      # pitch angle
        self.theta_c = theta_c  # desired pitch angle
        self.phi = phi          # roll angle
        self.phi_c = phi_c      # desired roll angle
        self.v = v              # velocity
        self.v_c = v_c          # desired velocity
        self.gload = gload      # gload factor
        self.v_min = v_min      # minimum velocity
        self.v_max = v_max      # maximum velocity
        self.sensor_state = None
        self.tracking = False
        self.tracked = False
        self.contact_range = None
        self.contact_aa = None
        self.contact_ata = None
        self.los_angle = None
        self.mcgrew_angle = None
        self.mcgrew_range = None
        self.mcgrew_score = None
        self.lethal_range = False
        self.lethal_cone = False
        self.viable_lethal_shot = False
        self.opponent_viable_lethal_shot = False
        self.reward = 0

    @property
    def heading(self):
        """ Returns the current heading angle psi. """
        return self.psi

    @property
    def desired_heading(self):
        """ Returns the commanded heading angle psi_c. """
        return self.psi_c

    @property
    def pitch(self):
        """ Returns the current pitch angle theta. """
        return self.theta

    @property
    def desired_pitch(self):
        """ Return the commanded pitch angle theta_c. """
        return self.theta_c

    @property
    def desired_v(self):
        """ Returns the commanded/desired speed v_c. """
        return self.v_c

    @property
    def roll(self):
        """ Return the current roll angle phi. """
        return self.phi

    @property
    def desired_roll(self):
        """ Returns the commanded roll angle phi_c. """
        return self.phi_c

    @property
    def gload_factor(self):
        """ Returns the aircrafts gload. """
        return self.gload

    def pos_2d(self):
        """ Returns an (x,y) tuple representing the aircraft position. """
        return self.x, self.y

    def pos_3d(self):
        """ Returns an (x,y,z) tuple representing the aircraft position. """
        return self.x, self.y, self.z

    def __str__(self):
        """ String representation of the fighter state. """
        tokens = []
        tokens += ['x({})={}'.format(self.callsign, self.x)]
        tokens += ['y({})={}'.format(self.callsign, self.y)]
        tokens += ['z({})={}'.format(self.callsign, self.z)]
        tokens += ['z_c({})={}'.format(self.callsign, self.z_c)]
        tokens += ['phi({})={}'.format(self.callsign, self.phi)]
        tokens += ['phi_c({})={}'.format(self.callsign, self.phi_c)]
        tokens += ['psi({})={}'.format(self.callsign, self.psi)]
        tokens += ['psi_c({})={}'.format(self.callsign, self.psi_c)]
        tokens += ['theta({})={}'.format(self.callsign, self.theta)]
        tokens += ['theta_c({})={}'.format(self.callsign, self.theta_c)]
        tokens += ['v({})={}'.format(self.callsign, self.v)]
        tokens += ['v_c({})={}'.format(self.callsign, self.v_c)]
        tokens += ['gload({})={}'.format(self.callsign, self.gload)]
        return ', '.join(tokens)
